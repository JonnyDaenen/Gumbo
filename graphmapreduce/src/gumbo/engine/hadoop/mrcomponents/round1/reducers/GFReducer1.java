/**
 * Created: 22 Aug 2014
 */
package gumbo.engine.hadoop.mrcomponents.round1.reducers;

import gumbo.engine.hadoop.mrcomponents.tools.ParameterPasser;
import gumbo.engine.hadoop.settings.HadoopExecutorSettings;
import gumbo.engine.settings.AbstractExecutorSettings;
import gumbo.structures.gfexpressions.io.Pair;
import gumbo.structures.gfexpressions.operations.ExpressionSetOperations;

import java.io.IOException;
import java.util.HashSet;
import java.util.Set;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.output.MultipleOutputs;

/**
 * Uses atom data generated by the corresponding mapper.
 * 
 * @author Jonny Daenen
 * 
 */
public class GFReducer1 extends Reducer<Text, Text, Text, IntWritable> {

	private final static String FILENAME = "tmp_round1_red.txt";

	protected Text out1 = new Text();
	protected IntWritable out2 = new IntWritable();
	private ExpressionSetOperations eso;
	protected MultipleOutputs<Text, IntWritable> mos;

	private static final Log LOG = LogFactory.getLog(GFReducer1.class);

	StringBuilder sb;

	boolean outputIDs = true;
	HadoopExecutorSettings settings;


	/**
	 * @see org.apache.hadoop.mapreduce.Mapper#setup(org.apache.hadoop.mapreduce.Mapper.Context)
	 */
	@Override
	protected void setup(Context context) throws IOException, InterruptedException {
		// load context
		super.setup(context);
		Configuration conf = context.getConfiguration();

		String s = String.format("Reducer"+this.getClass().getSimpleName()+"-%05d-%d",
				context.getTaskAttemptID().getTaskID().getId(),
				context.getTaskAttemptID().getId());
		LOG.info(s);

		mos = new MultipleOutputs<>(context);
		sb = new StringBuilder(128);

		// load parameters
		try {
			ParameterPasser pp = new ParameterPasser(conf);
			eso = pp.loadESO();
			settings = pp.loadSettings();
		} catch (Exception e) {
			throw new InterruptedException("Mapper initialisation error: " + e.getMessage());
		}
		
		// dummy usage
		eso.getClass();
	}

	@Override
	protected void cleanup(Context context) throws IOException, InterruptedException {
		mos.close();
	}

	/**
	 * @see org.apache.hadoop.mapreduce.Reducer#reduce(java.lang.Object,
	 *      java.lang.Iterable, org.apache.hadoop.mapreduce.Reducer.Context)
	 */
	@Override
	protected void reduce(Text key, Iterable<Text> values, Context context) throws IOException, InterruptedException {

		Set<Pair<String, Integer>> buffer = new HashSet<>();
		



		boolean keyFound = false;

		// WARNING Text object will be reused by Hadoop!
		for (Text t : values) {

			//			if (print)
			//				LOG.error("Red1: " + key + " " + t);

			// parse input
			Pair<String, Integer> split = split(t);

			// is this not the key (key is only thing that can appear without atom reference)
			// it does not matter whether it's sent as S(1) or with a constant symbol such as '#'
			if (split.snd != -1) {


				// if the key has already been found, we can just output
				if (keyFound) {
					out1.set(split.fst);
					out2.set(split.snd);
					//					System.out.println("Writing: " + out1.toString() + " " + out2.toString() + "" + split.snd);
					mos.write(out1, out2, FILENAME);
					context.getCounter(GumboRed1Counter.RED1_OUT_BYTES).increment(out1.getLength() + Integer.SIZE/8);
					context.getCounter(GumboRed1Counter.RED1_OUT_RECORDS).increment(1);
					//					if (print)
					//						LOG.error("Red1 Out: " + out1 + " " + out2);
				}
				// else we buffer the data
				// if the optimization is off
				else if (!settings.getBooleanProperty(AbstractExecutorSettings.round1FiniteMemoryOptimizationOn)){
					buffer.add(split);
					context.getCounter(GumboRed1Counter.RED1_BUFFEREDITEMS).increment(1);
				// if optimization is on, we know that if the key is not there, we can skip the rest
				} else {
//					System.out.println("BUFFER COLLISION: " + t);
					context.getCounter(GumboRed1Counter.RED1_PREMATURE_ABORTS).increment(1);
					// skip loop
					 break;
				}

				// if this is the key, we mark it
			} else if (!keyFound) {
//				System.out.println("key found: " + t);
				keyFound = true;
			}
		}

		// output the remaining data
		if (keyFound) {
			for (Pair<String, Integer> p : buffer) {
				out1.set(p.fst);
				out2.set(p.snd);
				mos.write(out1, out2, FILENAME);
				context.getCounter(GumboRed1Counter.RED1_OUT_BYTES).increment(out1.getLength() + Integer.SIZE/8);
			}
		}

	}

	/**
	 * Splits String into 2 parts. String is supposed to be separated with ';'.
	 * When no ';' is present, the numeric value is -1. 
	 * @param t
	 */
	protected Pair<String, Integer> split(Text t) {
		
		int length = t.getLength();
		String output = null;
		int num = -1;
		sb.setLength(0);
		boolean numberPart = false;

		byte[] b = t.getBytes();
		for (int i = 0; i < length; i++) { // FUTURE for unicode this doesn't
			// work I guess..
			char c = (char)b[i];
			// if we find the semicolon
			if (c == ';') {
				numberPart = true;
				num = 0;
				// assemble number
			} else if (numberPart && ( '0' <= c && c <= '9')){
				num *= 10;
				num +=  c - '0';

			} else {
				sb.append((char) b[i]);
			}
		}

		output = sb.toString();

		return new Pair<>(output, num);

	}
	
	

}
